library ieee;
use ieee.std_logic_1164.all;

-- arithmetic functions with signed or unsigned values
use ieee.numeric_std.all;

library axi_filter_dma_v1_00_a;
use axi_filter_dma_v1_00_a.all;

--! This component implements the label selection and region detection algorithm based on the runs generated by the run-length encoder.

--! Inputs are the runs generated by the run-length encoder. The results are stored in an internal BRAM which can be read out using the
--! #FEATURE_BRAM_READOUT and #FEATURE_BRAM_RADDR ports.
--!
--! @see rle
--! @see region_detect
entity label_selection is
  generic(
        ROW_LENGTH                  : positive; --! Length of a row in the input image
        ROW_LENGTH_WIDTH            : positive; --! Bitwidth of #ROW_LENGTH
        NUMBER_OF_ROWS              : positive; --! Number of rows in the input image
        ROW_NUMBER_WIDTH            : positive; --! Bitwidth of #NUMBER_OF_ROWS
        MAX_NUMBER_LABELS           : positive; --! Maximum number of supported labels
        FEATURE_BRAM_ADDR_WIDTH     : positive; --! Address width for the BRAM holding the detected regions
        NUMBER_ROWS_BRAM            : positive := 3; --! The number of rows that need to be buffered in a BRAM in order to cache previously detected runs.
    SIMULATION                  : std_logic := '0'  --! Simulation mode
    );
  port(
        clk                         : in std_logic; --! cLock input
        rstn                        : in std_logic; --! nEgated asynchronous reset
        start_pos                   : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0); --! Start pos of the currently detected run. @see rle.start_pos
        end_pos                     : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0); --! End pos of the currently detected run. @see rle.end_pos
        row_number                  : in std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0); --! Row number of the currently detected run. @see rle.row_number
        new_run                     : in std_logic; --! iNdicates whether a new run is available on #START_POS, #END_POS and #ROW_NUMBER. @see rle.new_run
        eol                         : in std_logic; --! iNdicates if the run-length encoder has reached the end of a row in the image. @see rle.eol
        eof                         : in std_logic; --! iNdicates if the run-length encoder has reached the end of the data stream.  @see rle.eof
        feature_bram_readout        : in std_logic; --! eNables the feature BRAM readout. Should only be set to '1' if all image processing steps have been completed (#IDLE = '1').
        feature_bram_raddr          : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0); --! Read addres for the feature BRAM
        feature_bram_left_border    : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0); --! Left border of the feature stored at the current BRAM address #FEATURE_BRAM_RADDR
        feature_bram_right_border   : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0); --! Right border of the feature stored at the current BRAM address #FEATURE_BRAM_RADDR
        feature_bram_upper_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0); --! Upper border of the feature stored at the current BRAM address #FEATURE_BRAM_RADDR
        feature_bram_lower_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0); --! Lower border of the feature stored at the current BRAM address #FEATURE_BRAM_RADDR
        feature_bram_valid          : out std_logic; --! indicates if the feature at the current BRAM address #FEATURE_BRAM_RADDR is valid. Invalid features should be ignored.
        feature_bram_count          : out std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0); --! Outputs the total number of features in the BRAM. The value of #FEATURE_BRAM_RADDR should always be lower than this number.
        idle                        : out std_logic --! Indicates whether the component is IDLE (i.e. all image data has been processed completely)

    );
end label_selection;

architecture behavioral of label_selection is

    type RUN_TYPE is
        record
            start_pos   : unsigned(ROW_LENGTH_WIDTH-1 downto 0);
            end_pos     : unsigned(ROW_LENGTH_WIDTH-1 downto 0);
            run_label   : unsigned(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
            row_number  : unsigned(ROW_NUMBER_WIDTH-1 downto 0);
        end record;

    type RESULT_TYPE is (a, b, c, d, e, z);

    function getAddrWidthBram return integer is    --calculates the size of the BRAM
        variable addr_width : integer := 0;
        variable frame_res : integer := ROW_LENGTH * NUMBER_ROWS_BRAM;
    begin
        while 2**addr_width < frame_res loop
            addr_width := addr_width + 1;
        end loop;
        return addr_width;
    end function getAddrWidthBram;

    function packRun (in_vector : std_logic_vector) return RUN_TYPE is
        variable out_run : RUN_TYPE;
        variable run_size : integer := ROW_LENGTH_WIDTH + ROW_LENGTH_WIDTH + FEATURE_BRAM_ADDR_WIDTH + ROW_NUMBER_WIDTH;
        variable offset_start_pos : integer := ROW_LENGTH_WIDTH + FEATURE_BRAM_ADDR_WIDTH + ROW_NUMBER_WIDTH;
        variable offset_end_pos : integer := FEATURE_BRAM_ADDR_WIDTH + ROW_NUMBER_WIDTH;
        variable offset_run_label : integer := ROW_NUMBER_WIDTH;
        variable offset_row_number : integer := 0;
    begin
        out_run.start_pos := unsigned(in_vector(run_size - 1 downto offset_start_pos));
        out_run.end_pos := unsigned(in_vector(offset_start_pos - 1 downto offset_end_pos));
        out_run.run_label := unsigned(in_vector(offset_end_pos - 1 downto offset_run_label));
        out_run.row_number := unsigned(in_vector(offset_run_label - 1 downto offset_row_number));
        return out_run;
    end function;

    function unpackRun (in_run : RUN_TYPE) return std_logic_vector is
        variable run_size : integer := ROW_LENGTH_WIDTH + ROW_LENGTH_WIDTH + FEATURE_BRAM_ADDR_WIDTH + ROW_NUMBER_WIDTH;
        variable out_vector : std_logic_vector(run_size - 1 downto 0);
    begin
        out_vector := std_logic_vector(in_run.start_pos) &
                      std_logic_vector(in_run.end_pos) &
                      std_logic_vector(in_run.run_label) &
                      std_logic_vector(in_run.row_number);
        return out_vector;
    end function;

    function updateLabel(in_run : RUN_TYPE; new_label : unsigned) return RUN_TYPE is
        variable out_run : RUN_TYPE;
    begin
        out_run.start_pos := in_run.start_pos;
        out_run.end_pos := in_run.end_pos;
        out_run.run_label := new_label;
        out_run.row_number := in_run.row_number;
        return out_run;
    end function;

component ram_tp is
    generic (
        ADDR_WIDTH      : positive := 2;
        DATA_WIDTH      : positive := 6;
        USE_OUTPUT_REG  : std_logic := '0'
    );
    port (
        clk             : in std_logic;
        w_addr          : in std_logic_vector(ADDR_WIDTH-1 downto 0);
        w_data          : in std_logic_vector(DATA_WIDTH-1 downto 0);
        w_enable        : in std_logic;
        r_addr_1        : in std_logic_vector(ADDR_WIDTH-1 downto 0);
        r_data_1        : out std_logic_vector(DATA_WIDTH-1 downto 0);
        r_addr_2        : in std_logic_vector(ADDR_WIDTH-1 downto 0);
        r_data_2        : out std_logic_vector(DATA_WIDTH-1 downto 0)
    );
    end component;

    component  feature_label_check is
    generic(
        ROW_LENGTH_WIDTH            : positive := 10;
        ROW_NUMBER_WIDTH            : positive := 9;
        FEATURE_BRAM_ADDR_WIDTH     : positive := 11
    );
    port(
        clk                         : in std_logic;
        rstn                        : in std_logic;

        new_feature                 : in std_logic;
        update                      : in std_logic;
        merge                       : in std_logic;
        run_label_1                 : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        run_label_2                 : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        start_pos                   : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        end_pos                     : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        row_number                  : in std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);

        feature_bram_readout        : in std_logic;
        feature_bram_raddr          : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        feature_bram_left_border    : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        feature_bram_right_border   : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        feature_bram_upper_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        feature_bram_lower_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        feature_bram_valid          : out std_logic
    );
    end component;

    component feature_calculation is
    generic(
        ROW_LENGTH                  : positive := 640;
        ROW_LENGTH_WIDTH            : positive := 10;
        NUMBER_OF_ROWS              : positive := 480;
        ROW_NUMBER_WIDTH            : positive := 9;
        MAX_NUMBER_LABELS           : positive := 2045;
        FEATURE_BRAM_ADDR_WIDTH     : positive := 11
    );
    port(
        clk                         : in std_logic;
        rstn                        : in std_logic;

        new_feature                 : in std_logic;
        update                      : in std_logic;
        merge                       : in std_logic;
        run_label_1                 : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        run_label_2                 : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        start_pos                   : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        end_pos                     : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        row_number                  : in std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);

        feature_bram_readout        : in std_logic;
        feature_bram_raddr          : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        feature_bram_left_border    : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        feature_bram_right_border   : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        feature_bram_upper_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        feature_bram_lower_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        feature_bram_valid          : out std_logic
    );
    end component;

    constant ADDR_WIDTH_BRAM : integer := getAddrWidthBram;
    constant MAX_NUMBER_RUNS : integer := 2**ADDR_WIDTH_BRAM;
    constant DATA_WIDTH_BRAM : integer := 2 * ROW_LENGTH_WIDTH + ROW_NUMBER_WIDTH + FEATURE_BRAM_ADDR_WIDTH;

    -- Interface signals for feature calculation/check
    signal update_feature_label      : std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
    signal merge_feature_label       : std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
    signal update_feature_start_pos  : std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
    signal update_feature_end_pos    : std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
    signal update_feature_row_number : std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
    signal update_feature            : std_logic;
    signal merge_feature             : std_logic;
    signal new_feature               : std_logic;
    
    signal feature_count        : std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
    
    -- Interface signals for the TP RAM
    -- STUDENT CODE HERE
    
    -- STUDENT CODE until HERE

    -- RAM pointers
    -- STUDENT CODE HERE
    
    -- STUDENT CODE until HERE

    -- Interprocess synchronisation
    -- STUDENT CODE HERE
    
    -- STUDENT CODE until HERE
    
    -- Idle control signals
    -- STUDENT CODE HERE
    
    -- STUDENT CODE until HERE

    -- Run read control signals
    -- STUDENT CODE HERE
    
    -- STUDENT CODE until HERE

    -- Run compare signals
    -- STUDENT CODE HERE
    
    -- STUDENT CODE until HERE

begin
    G_FEATURE_CALCULATION : if SIMULATION = '0' generate
    begin
        -- A module to calculate features from labelled runs
        feature_calculation_module : feature_calculation
        generic map (
            ROW_LENGTH              => ROW_LENGTH,
            ROW_LENGTH_WIDTH        => ROW_LENGTH_WIDTH,
            NUMBER_OF_ROWS          => NUMBER_OF_ROWS,
            ROW_NUMBER_WIDTH        => ROW_NUMBER_WIDTH,
            MAX_NUMBER_LABELS       => MAX_NUMBER_LABELS,
            FEATURE_BRAM_ADDR_WIDTH => FEATURE_BRAM_ADDR_WIDTH
        )
        port map (
            clk                       => clk,
            rstn                      => rstn,

            run_label_1               => update_feature_label,
            run_label_2               => merge_feature_label,
            start_pos                 => update_feature_start_pos,
            end_pos                   => update_feature_end_pos,
            row_number                => update_feature_row_number,
            update                    => update_feature,
            merge                     => merge_feature,
            new_feature               => new_feature,
            feature_bram_readout      => feature_bram_readout,
            feature_bram_raddr        => feature_bram_raddr,
            feature_bram_left_border  => feature_bram_left_border,
            feature_bram_right_border => feature_bram_right_border,
            feature_bram_upper_border => feature_bram_upper_border,
            feature_bram_lower_border => feature_bram_lower_border,
            feature_bram_valid        => feature_bram_valid
        );
    end generate;

    G_FEATURE_LABEL_CHECK : if SIMULATION = '1' generate
    begin
        -- A module to verify run labels against a reference
        feature_label_check_module : feature_label_check
        generic map (
            ROW_LENGTH_WIDTH        => ROW_LENGTH_WIDTH,
            ROW_NUMBER_WIDTH        => ROW_NUMBER_WIDTH,
            FEATURE_BRAM_ADDR_WIDTH => FEATURE_BRAM_ADDR_WIDTH
        )
        port map (
            clk                       => clk,
            rstn                      => rstn,

            run_label_1               => update_feature_label,
            run_label_2               => merge_feature_label,
            start_pos                 => update_feature_start_pos,
            end_pos                   => update_feature_end_pos,
            row_number                => update_feature_row_number,
            update                    => update_feature,
            merge                     => merge_feature,
            new_feature               => new_feature,
            feature_bram_readout      => feature_bram_readout,
            feature_bram_raddr        => feature_bram_raddr,
            feature_bram_left_border  => feature_bram_left_border,
            feature_bram_right_border => feature_bram_right_border,
            feature_bram_upper_border => feature_bram_upper_border,
            feature_bram_lower_border => feature_bram_lower_border,
            feature_bram_valid        => feature_bram_valid
        );
    end generate;

    bram_runs: ram_tp
    generic map (
        ADDR_WIDTH     => ADDR_WIDTH_BRAM,
        DATA_WIDTH     => DATA_WIDTH_BRAM,
        USE_OUTPUT_REG => '0'
    )
    port map (
        clk             => clk,
        w_addr          => bram_w_addr,
        w_data          => w_data_ram,
        w_enable        => w_enable,
        r_addr_1        => bram_read_addr_1,
        r_data_1        => bram_read_prev_run ,
        r_addr_2        => bram_read_addr_2,
        r_data_2        => bram_read_act_run
    );


    -- STUDENT CODE HERE

    -- STUDENT CODE until HERE

    -- A process to control the IDLE output.
    idle_ctrl : process(clk)
    begin
        if rising_edge(clk) then
            -- STUDENT CODE HERE
            
            -- STUDENT CODE until HERE
        end if;
    end process;

    -- A process to arbiter access to the BRAM. Prevents conflicts between
    -- writing new runs and updating the old ones.
    bram_write_mux : process(clk)
    begin
        if rising_edge(clk) then
            -- STUDENT CODE HERE
            
            -- STUDENT CODE until HERE
        end if;
    end process;

    -- STUDENT CODE HERE
    
    -- STUDENT CODE until HERE

    -- Run read controller. Manages the run read pointers and presents the correct
    -- current- and pre-row runs to the rest of the logic.
    run_read_ctrl : process(clk)
    begin
        if rising_edge(clk) then
            -- STUDENT CODE HERE
            
            -- STUDENT CODE until HERE
        end if;
    end process;

    -- A process to compare runs as described in the paper.
    run_compare : process(clk)
        -- STUDENT CODE HERE
        
        -- STUDENT CODE until HERE
    begin
        if rising_edge(clk) then
            -- STUDENT CODE HERE
            
            -- STUDENT CODE until HERE
        end if;
    end process;

    -- A process to control current- and pre-row run update requests. The requests are
    -- generated based on the result from run_compare.
    rd_ptr_updater : process(clk)
    begin
        if rising_edge(clk) then
            -- STUDENT CODE HERE
            
            -- STUDENT CODE until HERE
        end if;
    end process;

    -- A process to control label update and merge request pulses.
    label_update_ctrl : process(clk)
    begin
        if rising_edge(clk) then
            -- STUDENT CODE HERE
            
            -- STUDENT CODE until HERE
        end if;
    end process;

    -- A process that produces the signals to pass to G_FEATURE_CALCULATION or
    -- G_FEATURE_LABEL_CHECK.
    output_ctrl : process(clk)
    begin
        if rising_edge(clk) then
            -- STUDENT CODE HERE
            
            -- STUDENT CODE until HERE
        end if;
    end process;
    
    process(clk, rstn)
        variable v_feature_count     : std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);

    begin
        if rstn = '0' then
        -- STUDENT CODE HERE
        
        -- STUDENT CODE until HERE
        elsif rising_edge(clk)  then
        -- STUDENT CODE until HERE
        
        -- STUDENT CODE until HERE
        end if;
    end process;
    feature_bram_count <= feature_count;

end behavioral;
